<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AtLeast" xml:space="preserve">
    <value>{5, };At Least: These symbols represent a minimum number of matches that the pattern in front of it should try to match. Any matches above the minimum are also counted.  It can also be greedy or lazy, depending on the quantifiers following it.</value>
  </data>
  <data name="BoundaryAnchor" xml:space="preserve">
    <value>\b;Word Boundary: This pattern signals an empty string that isn't at the beginning or end of a word.</value>
  </data>
  <data name="BracketRange" xml:space="preserve">
    <value>[abc];Bracket Range: These symbols represent a range between the characters inside the brackets which includes all characters in sequence between and including the two characters at each end of the range.</value>
  </data>
  <data name="CaretAnchor" xml:space="preserve">
    <value>^;Start of String/Line: The caret signals the start of string or multiline pattern.</value>
  </data>
  <data name="ControlChar" xml:space="preserve">
    <value>\c;Control Character: This pattern represents the control button, and can be paired with other characters to signal the effect of pressing both the control button and the button represented by the character following it.</value>
  </data>
  <data name="DigitChar" xml:space="preserve">
    <value>\d;Digit Character: This pattern represents any digit 0-9, as well as digit characters from Unicode, which may include digits from other languages.  </value>
  </data>
  <data name="DollarAnchor" xml:space="preserve">
    <value>$;End of String: The dollar sign signals the end of a string or a line in a multiline pattern.</value>
  </data>
  <data name="Exact" xml:space="preserve">
    <value>{5};Exact Match: These symbols represent an exact limiter on how many matches should be found. It can also be greedy or lazy, depending on the quantifiers following it.</value>
  </data>
  <data name="FeedChar" xml:space="preserve">
    <value>\f;Form Feed: This pattern represents the form feed, or page break character.</value>
  </data>
  <data name="GreedyOne" xml:space="preserve">
    <value>+;Greedy One Match: This symbol represents a match of one or more times, and follows the character or pattern it is meant to find. It is called greedy because it will continue matching through the whole sequence instead of stopping after it finds a match. </value>
  </data>
  <data name="GreedyZero" xml:space="preserve">
    <value>*;Greedy Zero Match: This symbol represents a match of zero or more times, and follows the character or pattern it is meant to find. It is called greedy because it will continue matching through the whole sequence instead of stopping after it finds a match. This may result in it finding only one match when there are actually many matches because it waits until the end of the sequence to declare a match.</value>
  </data>
  <data name="GroupRange" xml:space="preserve">
    <value>(...);Group: These symbols represent a grouping, or a collection that has to be considered together for the purposes of matching a pattern.</value>
  </data>
  <data name="SubpatternNum" xml:space="preserve">
    <value>\x;Subpattern: This pattern represents a subpattern of the amount "x".</value>
  </data>
  <data name="HexStrChar" xml:space="preserve">
    <value>\xhh;Hexadecimal Characters: This pattern represents a grouping of hexadecimal characters.</value>
  </data>
  <data name="Lazy" xml:space="preserve">
    <value>?;Lazy Quantifier: This symbol represents a match of only zero or one times, and can be used in tandem with other qualifiers, in addition to on its own, to force matching to stop after the first match is found. It follows either the character or pattern it is meant to match or the quantifier it is meant to restrict.</value>
  </data>
  <data name="Literal" xml:space="preserve">
    <value>\;Escape the Following: This character represents the request to treat the following character as a literal character, instead of as a part of a special character.</value>
  </data>
  <data name="NewLine" xml:space="preserve">
    <value>\n;New Line: This pattern represents the command to start a new line.</value>
  </data>
  <data name="NonRange" xml:space="preserve">
    <value>[^a-q];Non-Range: These symbols represent a range between the characters inside the bracket, up to and including both ends of the range, which are excluded from matching.</value>
  </data>
  <data name="NonDigit" xml:space="preserve">
    <value>\D;Non-Digit Character: This pattern represents any non-digit character.</value>
  </data>
  <data name="NonOr" xml:space="preserve">
    <value>[^abc];Non-Or Range: These symbols represent a range which are excluded from pattern matching.</value>
  </data>
  <data name="NonWord" xml:space="preserve">
    <value>\W;Non-Word Characters: This pattern represents any non-word characters.</value>
  </data>
  <data name="NotSpace" xml:space="preserve">
    <value>\S;Non-White Space: This pattern represents white space that is not the spacebar, tab, return, or the form feed.</value>
  </data>
  <data name="OctalChar" xml:space="preserve">
    <value>\O;Octal Character: This pattern represents any grouping of digits that represent an octal value.</value>
  </data>
  <data name="OctalStr" xml:space="preserve">
    <value>\xxx;Octal Digits: This pattern represents a grouping of octal characters.</value>
  </data>
  <data name="OrBracket" xml:space="preserve">
    <value>[abc];Or Range: These symbols represent a range between the characters inside the brackets such that any of the character or all of them may be matched (exclusive or).</value>
  </data>
  <data name="OrRange" xml:space="preserve">
    <value>(a|b);Or: These symbols represent an or statement, in which at least one of the alternatives have to be true for the pattern to match.</value>
  </data>
  <data name="PassiveRange" xml:space="preserve">
    <value>(?:...);Passive Range: These symbols represent a grouping which the regex engine doesn't have to remember--it can be used to match and discarded.</value>
  </data>
  <data name="PeriodRange" xml:space="preserve">
    <value>.;Match Any: This character represents a match of any character except the new line character (\n).</value>
  </data>
  <data name="RangeQuant" xml:space="preserve">
    <value>{5,7};Quantity Range: These symbols represent a range of number of matches that the pattern should try to find. It is inclusive, allowing anything including the minimum and up to and including the maximum number of matches.  It can also be greedy or lazy, depending on the quantifiers following it.</value>
  </data>
  <data name="ReturnChar" xml:space="preserve">
    <value>\r;Return Character: This pattern represents the use of the return button.</value>
  </data>
  <data name="SpaceChar" xml:space="preserve">
    <value>\s;White Space Character: This pattern represents white space created by the spacebar or the use of the tab.</value>
  </data>
  <data name="StringBegin" xml:space="preserve">
    <value>\A;Start of String: This pattern signals the start of a string.</value>
  </data>
  <data name="StringEnd" xml:space="preserve">
    <value>\Z;End of String: This pattern signals the end of a string.</value>
  </data>
  <data name="TabChar" xml:space="preserve">
    <value>\t;Tab Character: This pattern represents the use of the tab button.</value>
  </data>
  <data name="VertTabChar" xml:space="preserve">
    <value>\v;Vertical Tab Character: This pattern represents the use of a vertical tab.</value>
  </data>
  <data name="WordChar" xml:space="preserve">
    <value>\w;Word Character: This pattern represents a word, defined as any grouping of one or more characters designated word characters, separated by any spacing character. Examples may include hyphens, brackets, and digits.</value>
  </data>
  <data name="WordEnd" xml:space="preserve">
    <value>\&gt;;End of Word: This pattern signals the end of a word.</value>
  </data>
  <data name="WordStart" xml:space="preserve">
    <value>\&lt;;Start of Word: This pattern signals the start of a word.</value>
  </data>
  <data name="AfterReplace" xml:space="preserve">
    <value>$' or \';After Matched String: This pattern allows the ability to insert a given sequence after the matched pattern.</value>
  </data>
  <data name="BeforeReplace" xml:space="preserve">
    <value>$` or \`;Before Matched String: This pattern allows the ability to insert a given sequence before the matched pattern.</value>
  </data>
  <data name="BeginLiteral" xml:space="preserve">
    <value>\Q;Begin Literal Sequence: This pattern is used to signal the beginning of a sequence that should be interpreted literally, not as a part of a pattern or special instructions to the regular expressions engine.</value>
  </data>
  <data name="Comment" xml:space="preserve">
    <value>?#;Comment: This pattern signals that the following sequence is a comment, and should be ignored by the regular expressions engine</value>
  </data>
  <data name="EndLiteral" xml:space="preserve">
    <value>\E;End Literal Sequence: This pattern is used to signal the end of a sequence that should be interpreted literally, not as a part of a pattern or special instructions to the regular expressions engine.</value>
  </data>
  <data name="EntireReplacement" xml:space="preserve">
    <value>$&amp; or \&amp;;Entire Matched String: This pattern allows the ability to insert a given pattern and replace the entire match or matches.</value>
  </data>
  <data name="FirstReplacement" xml:space="preserve">
    <value>$1 or \1;First Replacement: This pattern allows the ability to replace a given sequence with another in a pattern that has repeating elements.</value>
  </data>
  <data name="GlobalPattern" xml:space="preserve">
    <value>\g;Global Match: This pattern allows a search of all the items  in the given section for matching patterns.</value>
  </data>
  <data name="IfThen" xml:space="preserve">
    <value>?();If-Then: This pattern looks for a match conditionally, such that if the first condition is met, the second condition is searched for.</value>
  </data>
  <data name="IfThenElse" xml:space="preserve">
    <value>?()|;If-Then-Else: This pattern looks for a match conditionally, such that if the first condition is met, the second will be attempted. If it is not able to be matched, the last condition will be attempted.</value>
  </data>
  <data name="LastReplacement" xml:space="preserve">
    <value>$+ or \+;Last Matched String: This pattern allows the ability to insert a given pattern and replace the last match.</value>
  </data>
  <data name="Lookahead" xml:space="preserve">
    <value>?=;Lookahead: This pattern looks for a match and returns a true/false result for matching, leaving the engine at the beginning of the match.</value>
  </data>
  <data name="Lookbehind" xml:space="preserve">
    <value>?&lt;=;Lookbehind: This pattern looks for a match and returns a true/false result for matching, leaving the engine at the end of the match.</value>
  </data>
  <data name="NegLookahead" xml:space="preserve">
    <value>?!;Negative Lookahead: This pattern looks for a match and returns a true/false result for matching, leaving the engine at the beginning of a sequence that is not the pattern.</value>
  </data>
  <data name="NegLookbehind" xml:space="preserve">
    <value>?!= or ?&lt;!;Negative Lookbehind: This pattern looks for a match and returns a true/false result, leaving the engine at the end of a subsequence that is not the requested pattern.</value>
  </data>
  <data name="NthReplacement" xml:space="preserve">
    <value>$n or \n;Nth Non-Passive Replacement: This pattern allows the ability to dictate how many non-passive groups are matched and replaced.</value>
  </data>
  <data name="OnceOnly" xml:space="preserve">
    <value>?&gt;;Once-Only Subexpression: This pattern looks for a match and returns a true/false result, leaving the engine at the only match for the pattern in the sequence.</value>
  </data>
  <data name="SecondReplacement" xml:space="preserve">
    <value>$2 or \2;Second Replacement: This pattern allows the ability to replace a given sequence with another in a pattern that does not repeat. </value>
  </data>
  <data name="Assert" xml:space="preserve">
    <value>Assertions;These patterns are called assertions because they instruct the regex engine to forget everything but whether or not a match was found for the pattern.</value>
  </data>
  <data name="Anchors" xml:space="preserve">
    <value>Anchors;These patterns are used to indicate search boundaries, whether for words, lines, or their negations. </value>
  </data>
  <data name="Character" xml:space="preserve">
    <value>Character Classes;These patterns are used to represent special characters and indicate the type of characters for the pattern.</value>
  </data>
  <data name="Escape" xml:space="preserve">
    <value>Escape Characters;These patterns are used to indicate that the symbols contained within or just following one of these characters are to be treated literally, instead of as special or reserved characters.</value>
  </data>
  <data name="Group" xml:space="preserve">
    <value>Groups and Ranges;These patterns are used to indicate a group or range for a pattern, rather than a word. Ranges are inclusive and sequential.</value>
  </data>
  <data name="Mod" xml:space="preserve">
    <value>Pattern Modifiers;These patterns are used to indicate the extent of matching, or how long the engine should search.</value>
  </data>
  <data name="Quant" xml:space="preserve">
    <value>Quantifiers;These patterns are used to indicate a frequency for matches, allowing repeated characters or words to be matched according to the number of times specified.</value>
  </data>
  <data name="Replace" xml:space="preserve">
    <value>String Replacement;These patterns are used to locate and replace strings and portions of strings.</value>
  </data>
  <data name="Special" xml:space="preserve">
    <value>Special Characters;These patterns are reserved characters, used to indicate non-digit or letter characters which can be included in strings.</value>
  </data>
  <data name="HelpCalcDo" xml:space="preserve">
    <value>What do I do?;Enter any regular expression you wish to test into the input field and press calculate to see what patterns it matches in the sample text.</value>
  </data>
  <data name="HelpCalcMore" xml:space="preserve">
    <value>I need more help than this.;Toggle the option 'Plain Text' on the page beneath the forms.</value>
  </data>
  <data name="HelpCalcAnything" xml:space="preserve">
    <value>Why isn't it doing anything?;If there's an error in your pattern, a popup should appear that tells you what's wrong. If this does not occur, please contact me.</value>
  </data>
  <data name="HelpCalcWhy" xml:space="preserve">
    <value>Why a regular expressions calculator?;Regular expressions are a necessary part of understanding how to parse text efficiently, but they can be very difficult to understand. This calculator can help you learn them.</value>
  </data>
  <data name="HelpCalcWrong" xml:space="preserve">
    <value>What happens if I enter something wrong?;If you enter a pattern that won't resolve, a popup will tell you what's wrong.</value>
  </data>
  <data name="AboutMe" xml:space="preserve">
    <value>About Me;bio goes here</value>
  </data>
  <data name="NotWordBoundary" xml:space="preserve">
    <value>\B; Non-Word Boundary: This pattern represents any character that is not a word boundary.</value>
  </data>
  <data name="ExactRangeQuant" xml:space="preserve">
    <value>{5};Exact Range: These symbols represent an exact number of times the pattern is to be matched.</value>
  </data>
</root>