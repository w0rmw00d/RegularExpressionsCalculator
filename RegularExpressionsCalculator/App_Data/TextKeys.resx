<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AfterReplace" xml:space="preserve">
    <value>after replacement, after</value>
  </data>
  <data name="AtLeast" xml:space="preserve">
    <value>at least x times, at least</value>
  </data>
  <data name="BeforeReplace" xml:space="preserve">
    <value>before replacement, before</value>
  </data>
  <data name="BeginLiteral" xml:space="preserve">
    <value>literally, begin literal, interpret literally, literal</value>
  </data>
  <data name="BoundaryAnchor" xml:space="preserve">
    <value>boundary, word end</value>
  </data>
  <data name="BracketRange" xml:space="preserve">
    <value>x or y or z, any of the following</value>
  </data>
  <data name="CaretAnchor" xml:space="preserve">
    <value>beginning of word, beginning of line, begin</value>
  </data>
  <data name="ControlChar" xml:space="preserve">
    <value>control, control character</value>
  </data>
  <data name="DigitChar" xml:space="preserve">
    <value>digit, digits, digit characters</value>
  </data>
  <data name="DigitRange" xml:space="preserve">
    <value>digit range, any of the following digits</value>
  </data>
  <data name="DollarAnchor" xml:space="preserve">
    <value>end, end of word, end of line</value>
  </data>
  <data name="EndLiteral" xml:space="preserve">
    <value>literally, end literal, interpret literally literal</value>
  </data>
  <data name="EntireReplacement" xml:space="preserve">
    <value>replace whole, entire replacement, replace all</value>
  </data>
  <data name="Exact" xml:space="preserve">
    <value>match exactly x times, match exact x, exactly x</value>
  </data>
  <data name="FeedChar" xml:space="preserve">
    <value>feed character, feed</value>
  </data>
  <data name="FirstReplacement" xml:space="preserve">
    <value>first replacement, replace first</value>
  </data>
  <data name="GlobalPattern" xml:space="preserve">
    <value>global, search globally</value>
  </data>
  <data name="GreedyOne" xml:space="preserve">
    <value>greedy one, greedy match one or more, one or more, 1 or more</value>
  </data>
  <data name="GreedyZero" xml:space="preserve">
    <value>greedy zero, greedy match zero or more, zero or more, 0 or more</value>
  </data>
  <data name="GroupRange" xml:space="preserve">
    <value>anything in the following group, group range x, range x</value>
  </data>
  <data name="HexStrChar" xml:space="preserve">
    <value>hexadecimal characters, hex char, hex string char, hex string</value>
  </data>
  <data name="IfThen" xml:space="preserve">
    <value>if x then y, if x else y, if x do y</value>
  </data>
  <data name="IfThenElse" xml:space="preserve">
    <value>if x then y else z, if x else y finally z, if x do y else z</value>
  </data>
  <data name="LastReplacement" xml:space="preserve">
    <value>last replacement</value>
  </data>
  <data name="Lazy" xml:space="preserve">
    <value>lazy, lazy match, lazily, lazily match</value>
  </data>
  <data name="Literal" xml:space="preserve">
    <value>literal, literally</value>
  </data>
  <data name="Lookahead" xml:space="preserve">
    <value>look ahead, lookahead, search before match</value>
  </data>
  <data name="Lookbehind" xml:space="preserve">
    <value>look behind, lookbehind, search after match</value>
  </data>
  <data name="NegLookahead" xml:space="preserve">
    <value>negative look ahead, negative lookahead, neg lookahead, neg look ahead</value>
  </data>
  <data name="NegLookbehind" xml:space="preserve">
    <value>negative look behind, negative lookbehind, neg lookbehind, neg look behind</value>
  </data>
  <data name="NewLine" xml:space="preserve">
    <value>new line, newline</value>
  </data>
  <data name="NonDigit" xml:space="preserve">
    <value>non digit, non-digit, not digit</value>
  </data>
  <data name="NonOrRange" xml:space="preserve">
    <value>non or range x, not x or y or z </value>
  </data>
  <data name="NonRange" xml:space="preserve">
    <value>non range x, nonrange x, not x </value>
  </data>
  <data name="NonWord" xml:space="preserve">
    <value>non-word, nonword, non word, not words, not word character, non word char</value>
  </data>
  <data name="NotSpace" xml:space="preserve">
    <value>not space, nonspace</value>
  </data>
  <data name="NotWordBoundary" xml:space="preserve">
    <value>not word boundary, non-word boundary</value>
  </data>
  <data name="NthReplacement" xml:space="preserve">
    <value>nth replacement, nth replace, replace nth, x replacement</value>
  </data>
  <data name="OctalChar" xml:space="preserve">
    <value>octalchar x, octal character x, octal char x</value>
  </data>
  <data name="OctalStr" xml:space="preserve">
    <value>octalstr x, octalstring x, octal string x</value>
  </data>
  <data name="OnceOnly" xml:space="preserve">
    <value>onceonly, once only, match only once</value>
  </data>
  <data name="OrBracket" xml:space="preserve">
    <value>or, x or y or z, any of the following x</value>
  </data>
  <data name="OrRange" xml:space="preserve">
    <value>or, x or y</value>
  </data>
  <data name="PassiveRange" xml:space="preserve">
    <value>passiverange, passive match, passive x</value>
  </data>
  <data name="PeriodRange" xml:space="preserve">
    <value>match any character, match any char, match any x</value>
  </data>
  <data name="RangeQuant" xml:space="preserve">
    <value>at least x to y, at least x and no more than y, match x to y, match x-y</value>
  </data>
  <data name="ReturnChar" xml:space="preserve">
    <value>return, returnchar, returncharacter, return character, return char</value>
  </data>
  <data name="SecondReplacement" xml:space="preserve">
    <value>second replacement, second replace, 2nd replace</value>
  </data>
  <data name="SpaceChar" xml:space="preserve">
    <value>space, spacechar, spacecharacter, space char, space character</value>
  </data>
  <data name="StringBegin" xml:space="preserve">
    <value>begin string, string begin, strbegin, beginning of string</value>
  </data>
  <data name="StringEnd" xml:space="preserve">
    <value>end string, string end, strend, end of string</value>
  </data>
  <data name="SubpatternNum" xml:space="preserve">
    <value>subpattern num x, subpattern x, sub num x</value>
  </data>
  <data name="SubPatternRange" xml:space="preserve">
    <value>subpattern range x, sub range x</value>
  </data>
  <data name="TabChar" xml:space="preserve">
    <value>tab, tabchar, tabcharacter, tab char, tab character</value>
  </data>
  <data name="VertTabChar" xml:space="preserve">
    <value>verttab, vert tab, verttabchar, vertchar</value>
  </data>
  <data name="WordChar" xml:space="preserve">
    <value>word x, wordchar x</value>
  </data>
  <data name="WordEnd" xml:space="preserve">
    <value>wordend, word end, end of word</value>
  </data>
  <data name="WordStart" xml:space="preserve">
    <value>wordstart, word start, start of word</value>
  </data>
</root>